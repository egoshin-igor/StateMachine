<PROG> -> void main {~VTC.CreateTable <body> }~VTC.DestroyLastTable / void

<body> -> <declarations> <body___10000> / @@@,bool,char,float,int,IntArray,string
<body___10000> -> [EPS] / }
<body___10000> -> <operators> / #IDENTIFIER#,Print,Println,if,while,Read

<declarations> -> <declarations_0> @@@ / @@@,bool,char,float,int,IntArray,string,double
<declarations_0> -> [EPS] / @@@
<declarations_0> -> <declaration> `~AO.Clear <declarations_0> / bool,char,float,int,IntArray,string,double
<declaration> -> <type> #IDENTIFIER#~VTC.DefineIdentifier / bool,char,float,int,IntArray,string,double

<type> -> bool~VTC.DefineNewType / bool
<type> -> char~VTC.DefineNewType / char
<type> -> float~VTC.DefineNewType / float
<type> -> int~VTC.DefineNewType / int
<type> -> IntArray~VTC.DefineNewType / IntArray
<type> -> string~VTC.DefineNewType / string
<type> -> double~VTC.DefineNewType / double

<operators> -> <operator> <operators___10000> / #IDENTIFIER#,Print,Println,if,while,Read

<operators___10000> -> [EPS] / }
<operators___10000> -> <operators> / #IDENTIFIER#,Print,Println,if,while,Read

<operator> -> <leftValue> = <rightValue>~Common.CheckRightValueDestination `~TC.CheckLeftRight / #IDENTIFIER#
<operator> -> <print> `~AO.Clear / Print,Println
<operator> -> <ifExpression> / if
<operator> -> <whileExpression> / while
<operator> -> <read> `~AO.Clear / Read

<print> -> Print~Print.Save ( <printValue> )~Print.GenerateNode / Print
<print> -> Println~Print.Save ( <printValue> )~Print.GenerateNode / Println

<printValue> -> #DecimalWholeNumber#~Print.Save / #DecimalWholeNumber#
<printValue> -> #IDENTIFIER#~Print.Save / #IDENTIFIER#
<printValue> -> [EPS] / )

<read> -> Read~Read.Save ( <readValue> )~Read.GenerateNode / Read
<readValue> -> #IDENTIFIER#~Read.Save / #IDENTIFIER#

<ariphmeticalOperation> -> <ariphmeticalOperation_0> <ariphmeticalOperation_1> / -,(,#BinaryWholeNumber#,#DecimalWholeNumber#,#IDENTIFIER#,#DecimalFixedPointNumber#
<ariphmeticalOperation_0> -> <number> <mulArOp>~AO.ActionCreateUnaryMinusNode / -,(,#BinaryWholeNumber#,#DecimalWholeNumber#,#IDENTIFIER#,#DecimalFixedPointNumber#

<mulArOp> -> *~AO.ActionAfterSign <number> <mulArOp>~AO.ActionAfterOperation / *
<mulArOp> -> div~AO.ActionAfterSign <number> <mulArOp>~AO.ActionAfterOperation / div
<mulArOp> -> [EPS] / -,),`,+

<ariphmeticalOperation_1> -> -~AO.ActionAfterSign <ariphmeticalOperation_0> <ariphmeticalOperation_1>~AO.ActionAfterOperation / -
<ariphmeticalOperation_1> -> +~AO.ActionAfterSign <ariphmeticalOperation_0> <ariphmeticalOperation_1>~AO.ActionAfterOperation / +
<ariphmeticalOperation_1> -> [EPS] / ),`

<number> -> -~AO.UnaryMinusFoundAction <number> / -
<number> -> (~AO.OpenBracketFound <ariphmeticalOperation> )~AO.ClosedBracketFound / (
<number> -> <number2> / #BinaryWholeNumber#,#DecimalWholeNumber#,#IDENTIFIER#,#DecimalFixedPointNumber#
<number2> -> #BinaryWholeNumber#~AO.ActionAfterNumber / #BinaryWholeNumber#
<number2> -> #DecimalWholeNumber#~AO.ActionAfterNumber / #DecimalWholeNumber#
<number2> -> #DecimalFixedPointNumber#~AO.ActionAfterNumber / #DecimalFixedPointNumber#
<number2> -> #IDENTIFIER#~AO.ActionAfterNumber / #IDENTIFIER#

<leftValue> -> #IDENTIFIER#~TC.SaveLeftTerm / #IDENTIFIER#

<ariphmeticalOperation_rv> -> <ariphmeticalOperation> / -,(,#BinaryWholeNumber#,#DecimalWholeNumber#,#IDENTIFIER#,#DecimalFixedPointNumber#
<rightValue> -> <ariphmeticalOperation_rv> / -,(,#BinaryWholeNumber#,#DecimalWholeNumber#,#IDENTIFIER#,#DecimalFixedPointNumber#
<rightValue> -> <boolExpression_0> / !,(,#IDENTIFIER#,false,true,#DecimalWholeNumber#

<boolExpression_0> -> <boolExpression> / !,(,#IDENTIFIER#,false,true,#DecimalWholeNumber#
<boolExpression> -> <boolOperations> <boolExpression___10000>~BO.ActionAfterCompOperation / !,(,#IDENTIFIER#,false,true,#DecimalWholeNumber#
<boolExpression___10000> -> &&~BO.ActionAfterLogicSign <boolExpression> / &&
<boolExpression___10000> -> [EPS]~BO.ActionAfterCompOperation / `,)
<boolExpression___10000> -> ||~BO.ActionAfterLogicSign <boolExpression> / ||
<boolOperations> -> <boolValue> <boolOperations___10000> / !,(,#IDENTIFIER#,false,true,#DecimalWholeNumber#
<boolOperations___10000> -> !=~BO.ActionAfterCompSign <boolValue> / !=
<boolOperations___10000> -> [EPS] / &&,`,),||
<boolOperations___10000> -> <~BO.ActionAfterCompSign <boolValue> / <
<boolOperations___10000> -> <=~BO.ActionAfterCompSign <boolValue> / <=
<boolOperations___10000> -> ==~BO.ActionAfterCompSign <boolValue> / ==
<boolOperations___10000> -> >~BO.ActionAfterCompSign <boolValue> / >
<boolOperations___10000> -> >=~BO.ActionAfterCompSign <boolValue> / >=
<boolValue> -> !~BO.UnaryNotSignFound <boolValue> / !
<boolValue> -> (~BO.OpenBracketFound <boolExpression> )~BO.ClosedBracketFound / (
<boolValue> -> <boolValue2> / #IDENTIFIER#,false,true,#DecimalWholeNumber#
<boolValue2> -> #IDENTIFIER#~BO.ActionAfterBoolValue / #IDENTIFIER#
<boolValue2> -> false~BO.ActionAfterBoolValue / false
<boolValue2> -> true~BO.ActionAfterBoolValue / true
<boolValue2> -> #DecimalWholeNumber#~BO.ActionAfterBoolValue / #DecimalWholeNumber#

<ifExpression> -> if ( <boolExpression_0> )~IF.AddIf { <operators> }~IF.AddThenEnd <ifExpression_else> / if
<ifExpression_else> -> [EPS] / #IDENTIFIER#,Print,Println,if,}
<ifExpression_else> -> else {~IF.AddElseBegin <operators> }~IF.AddElseEnd / else

<whileExpression> -> while ( <boolExpression_0> )~While.AddWhile { <operators> }~While.AddWhileEnd / while